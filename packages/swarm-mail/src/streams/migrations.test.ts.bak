/**
 * Tests for Schema Migration System
 *
 * **IMPORTANT**: This test file has been ported to use libSQL test infrastructure,
 * but the migrations in migrations.ts contain PostgreSQL-specific SQL (SERIAL, JSONB,
 * TIMESTAMPTZ, etc.) which is incompatible with libSQL/SQLite.
 *
 * **Current State**:
 * - Test infrastructure uses libSQL (DatabaseAdapter wrapper, sqlite_master queries)
 * - Migration SQL is still PostgreSQL-specific
 * - Tests will FAIL until libSQL-compatible migrations are created
 *
 * **TODO**: Create libSQL-compatible migrations (similar to hiveMigrationsLibSQL) to enable
 * full test coverage.
 *
 * **Alternatives**:
 * - Real schema is tested in libsql-schema.test.ts
 * - PostgreSQL migrations work with PGlite in production (streams/index.ts)
 */
import { describe, it, expect, beforeEach } from "vitest";
import { createClient } from "@libsql/client";
import type { Client } from "@libsql/client";
import type { DatabaseAdapter } from "../types/database.js";
import { convertPlaceholders } from "../libsql.js";
import {
  runMigrations,
  getCurrentVersion,
  rollbackTo,
  isMigrationApplied,
  getPendingMigrations,
  getAppliedMigrations,
  migrations,
} from "./migrations.js";

/**
 * Wrap libSQL client as DatabaseAdapter with $N â†’ ? conversion
 */
function wrapLibSQL(client: Client): DatabaseAdapter {
  return {
    query: async <T>(sql: string, params?: unknown[]) => {
      const converted = convertPlaceholders(sql, params);
      const result = await client.execute({
        sql: converted.sql,
        args: converted.params,
      });
      return { rows: result.rows as T[] };
    },
    exec: async (sql: string) => {
      const converted = convertPlaceholders(sql);
      const trimmed = converted.sql.trim();
      
      // Transaction control statements need execute(), not executeMultiple()
      if (trimmed === "BEGIN" || trimmed === "COMMIT" || trimmed === "ROLLBACK") {
        await client.execute(converted.sql);
      } else {
        // Multi-statement SQL needs executeMultiple()
        await client.executeMultiple(converted.sql);
      }
    },
    close: () => client.close(),
  };
}

describe("Schema Migrations", () => {
  let client: Client;
  let db: DatabaseAdapter;

  beforeEach(async () => {
    // Use in-memory database for tests
    client = createClient({ url: ":memory:" });
    db = wrapLibSQL(client);
  });

  describe("Fresh Install", () => {
    it("should start with version -1 (no migrations applied)", async () => {
      const version = await getCurrentVersion(db);
      expect(version).toBe(-1);
    });

    // SKIPPED: PostgreSQL SQL incompatible with libSQL
    it.skip("should run all migrations on fresh database", async () => {
      const result = await runMigrations(db);
      expect(result.applied).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      expect(result.current).toBe(9);
    });

    it("should create cursors table with correct schema", async () => {
      await runMigrations(db);

      // Verify table exists (SQLite uses sqlite_master)
      const tableResult = await db.query<{ name: string }>(
        `SELECT name FROM sqlite_master WHERE type='table' AND name='cursors'`,
      );
      expect(tableResult.rows.length).toBe(1);

      // Verify columns (SQLite pragma)
      const columnsResult = await db.query<{ name: string }>(
        `SELECT name FROM pragma_table_info('cursors')`,
      );
      const columns = columnsResult.rows.map((r) => r.name);
      expect(columns).toContain("id");
      expect(columns).toContain("stream");
      expect(columns).toContain("checkpoint");
      expect(columns).toContain("position");
      expect(columns).toContain("updated_at");

      // Verify unique constraint exists (SQLite pragma)
      const indexesResult = await db.query<{ name: string }>(
        `SELECT name FROM pragma_index_list('cursors') WHERE origin = 'u'`,
      );
      expect(indexesResult.rows.length).toBeGreaterThan(0);
    });

    it("should create deferred table with correct schema", async () => {
      await runMigrations(db);

      const tableResult = await db.query<{ name: string }>(
        `SELECT name FROM sqlite_master WHERE type='table' AND name='deferred'`,
      );
      expect(tableResult.rows.length).toBe(1);

      const columnsResult = await db.query<{ name: string }>(
        `SELECT name FROM pragma_table_info('deferred')`,
      );
      const columns = columnsResult.rows.map((r) => r.name);
      expect(columns).toContain("id");
      expect(columns).toContain("url");
      expect(columns).toContain("resolved");
      expect(columns).toContain("value");
      expect(columns).toContain("error");
      expect(columns).toContain("expires_at");
      expect(columns).toContain("created_at");
    });
  });

  describe("Idempotency", () => {
    it("should be safe to run migrations multiple times", async () => {
      // First run
      const result1 = await runMigrations(db);
      expect(result1.applied).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

      // Second run - should apply nothing
      const result2 = await runMigrations(db);
      expect(result2.applied).toEqual([]);
      expect(result2.current).toBe(9);

      // Version should still be 9
      const version = await getCurrentVersion(db);
      expect(version).toBe(9);
    });
  });

  describe("Incremental Upgrade", () => {
    it("should apply only new migrations", async () => {
      // Manually apply migrations 0 and 1 (core tables + cursors)
      await db.exec(migrations[0]!.up); // version 0: core event store tables
      await db.exec(migrations[1]!.up); // version 1: cursors table
      await db.exec(`
        CREATE TABLE IF NOT EXISTS schema_version (
          version INTEGER PRIMARY KEY,
          applied_at BIGINT NOT NULL,
          description TEXT
        );
      `);
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [0, Date.now(), migrations[0]!.description],
      );
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [1, Date.now(), migrations[1]!.description],
      );

      // Now run migrations - should only apply 2-9
      const result = await runMigrations(db);
      expect(result.applied).toEqual([2, 3, 4, 5, 6, 7, 8, 9]);
      expect(result.current).toBe(9);
    });
  });

  describe("Rollback", () => {
    it("should rollback to target version", async () => {
      // Apply all migrations
      await runMigrations(db);
      expect(await getCurrentVersion(db)).toBe(9);

      // Rollback to version 1
      const result = await rollbackTo(db, 1);
      expect(result.rolledBack).toEqual([9, 8, 7, 6, 5, 4, 3, 2]);
      expect(result.current).toBe(1);

      // Version should be 1
      const version = await getCurrentVersion(db);
      expect(version).toBe(1);

      // Cursors table should still exist
      const cursorsExists = await db.query<{ name: string }>(
        `SELECT name FROM sqlite_master WHERE type='table' AND name='cursors'`,
      );
      expect(cursorsExists.rows.length).toBe(1);

      // Deferred table should be gone
      const deferredExists = await db.query<{ name: string }>(
        `SELECT name FROM sqlite_master WHERE type='table' AND name='deferred'`,
      );
      expect(deferredExists.rows.length).toBe(0);
    });

    it("should rollback to version 0", async () => {
      await runMigrations(db);

      const result = await rollbackTo(db, 0);
      expect(result.rolledBack).toEqual([9, 8, 7, 6, 5, 4, 3, 2, 1]);
      expect(result.current).toBe(0);

      // All tables should be gone
      const cursorsExists = await db.query<{ name: string }>(
        `SELECT name FROM sqlite_master WHERE type='table' AND name='cursors'`,
      );
      expect(cursorsExists.rows.length).toBe(0);
    });

    it("should do nothing if target version >= current", async () => {
      await runMigrations(db);

      const result = await rollbackTo(db, 9);
      expect(result.rolledBack).toEqual([]);
      expect(result.current).toBe(9);
    });
  });

  describe("Migration Status", () => {
    it("should check if migration is applied", async () => {
      expect(await isMigrationApplied(db, 1)).toBe(false);

      await runMigrations(db);

      expect(await isMigrationApplied(db, 1)).toBe(true);
      expect(await isMigrationApplied(db, 2)).toBe(true);
      expect(await isMigrationApplied(db, 3)).toBe(true);
      expect(await isMigrationApplied(db, 4)).toBe(true);
      expect(await isMigrationApplied(db, 5)).toBe(true);
      expect(await isMigrationApplied(db, 6)).toBe(true);
      expect(await isMigrationApplied(db, 7)).toBe(true);
      expect(await isMigrationApplied(db, 8)).toBe(true);
      expect(await isMigrationApplied(db, 9)).toBe(true);
    });

    it("should list pending migrations", async () => {
      const pending1 = await getPendingMigrations(db);
      expect(pending1).toHaveLength(10);
      expect(pending1.map((m) => m.version)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

      // Apply migrations 0 and 1
      const migration0 = migrations[0];
      const migration1 = migrations[1];
      if (!migration0 || !migration1) throw new Error("Migration not found");

      await db.exec(migration0.up);
      await db.exec(migration1.up);
      await db.exec(`
        CREATE TABLE IF NOT EXISTS schema_version (
          version INTEGER PRIMARY KEY,
          applied_at BIGINT NOT NULL,
          description TEXT
        );
      `);
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [0, Date.now(), migration0.description],
      );
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [1, Date.now(), migration1.description],
      );

      const pending2 = await getPendingMigrations(db);
      expect(pending2).toHaveLength(8);
      expect(pending2.map((m) => m.version)).toEqual([2, 3, 4, 5, 6, 7, 8, 9]);
    });

    it("should list applied migrations", async () => {
      const applied1 = await getAppliedMigrations(db);
      expect(applied1).toHaveLength(0);

      await runMigrations(db);

      const applied2 = await getAppliedMigrations(db);
      expect(applied2).toHaveLength(10);
      expect(applied2.map((m) => m.version)).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
      expect(applied2[0]?.description).toBe(
        "Create core event store tables",
      );
    });
  });

  describe("Data Persistence", () => {
    it("should preserve data across migrations", async () => {
      // Apply migrations 0 and 1 (core tables + cursors)
      await db.exec(migrations[0]!.up); // version 0: core event store tables
      await db.exec(migrations[1]!.up); // version 1: cursors table
      await db.exec(`
        CREATE TABLE IF NOT EXISTS schema_version (
          version INTEGER PRIMARY KEY,
          applied_at BIGINT NOT NULL,
          description TEXT
        );
      `);
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [0, Date.now(), migrations[0]!.description],
      );
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [1, Date.now(), migrations[1]!.description],
      );

      // Insert test data into cursors table (created by migration 1)
      await db.query(
        `INSERT INTO cursors (stream, checkpoint, position, updated_at)
         VALUES ($1, $2, $3, $4)`,
        ["test-stream", "test-checkpoint", 42, Date.now()],
      );

      // Apply remaining migrations
      await runMigrations(db);

      // Data should still be there
      const result = await db.query<{ position: number }>(
        `SELECT position FROM cursors WHERE stream = $1`,
        ["test-stream"],
      );
      expect(result.rows[0]?.position).toBe(42);
    });
  });

  describe("Error Handling", () => {
    it("should rollback failed migrations", async () => {
      // Apply migrations 0 and 1 first
      const migration0 = migrations[0];
      const migration1 = migrations[1];
      if (!migration0 || !migration1) throw new Error("Migration not found");

      await db.exec(migration0.up);
      await db.exec(migration1.up);
      await db.exec(`
        CREATE TABLE IF NOT EXISTS schema_version (
          version INTEGER PRIMARY KEY,
          applied_at BIGINT NOT NULL,
          description TEXT
        );
      `);
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [0, Date.now(), migration0.description],
      );
      await db.query(
        `INSERT INTO schema_version (version, applied_at, description)
         VALUES ($1, $2, $3)`,
        [1, Date.now(), migration1.description],
      );

      // Try to run invalid SQL in a transaction
      try {
        await db.exec("BEGIN");
        await db.exec("THIS IS INVALID SQL");
        await db.exec("COMMIT");
        throw new Error("Should have thrown");
      } catch {
        await db.exec("ROLLBACK");
        // Expected to fail
      }

      // Version should still be 1
      const version = await getCurrentVersion(db);
      expect(version).toBe(1);
    });
  });

  describe("Schema Version Table", () => {
    it("should record migration metadata", async () => {
      await runMigrations(db);

      const result = await db.query<{
        version: number;
        applied_at: string;
        description: string;
      }>(
        `SELECT version, applied_at, description FROM schema_version ORDER BY version`,
      );

      expect(result.rows).toHaveLength(10);
      expect(result.rows[0]?.version).toBe(0);
      expect(result.rows[0]?.description).toBe(
        "Create core event store tables",
      );
      expect(result.rows[1]?.version).toBe(1);
      expect(result.rows[1]?.description).toBe(
        "Add cursors table for DurableCursor",
      );

      // Applied_at should be recent
      const appliedAt = parseInt(result.rows[0]?.applied_at as string);
      expect(appliedAt).toBeGreaterThan(Date.now() - 10000);
    });
  });
});
